//
// STARSpan project
// Carlos A. Rueda
// starspan_gen_envisl - generate envi spectral library ...
// $Id$
//

#include "starspan.h"           
#include "traverser.h"       

#include <stdlib.h>
#include <string.h>
#include <assert.h>

// used to write the number of lines in header since this is
// done in two passes: the first one in which the number of
// lines is unknown, and a second one to update it.
#define LINES_WIDTH 8



/**
  * Populates the spectral library.
  */
class EnviSlObserver : public Observer {
public:
	int typeSize;
	int numBands;
	FILE* data_file;
	FILE* header_file;
	FILE* class_file;
	const char* select_fields;
	
	OGRFeature* currentFeature;
	int numSpectra;	
	long lines_offset;
	
	/**
	  * Initializes the header.
	  */
	EnviSlObserver(int bands, FILE* df, FILE* hf, FILE* cf, const char* select_fields_)
	: numBands(bands), data_file(df), header_file(hf), class_file(cf),
	  select_fields(select_fields_)
	{
		numSpectra = 0;
		
		// first part of header:
		fprintf(header_file,
			"ENVI\n" 
			"description = {Generated by starspan}\n"
			"samples = %d\n"
			"lines = "
			,
				numBands     // samples
		);
		
		// take current file pointer to later update number of lines:
		lines_offset = ftell(header_file);
		fprintf(header_file,
			"%*d\n"
			"bands = %d\n"
			"header offset = 0\n"
			"file type = ENVI Spectral Library\n"
			"data type = %d\n"
			"interleave = bip\n"
			"sensor type = Unknown\n"
			"byte order = %d\n"
			,
				LINES_WIDTH, 0, // lines--to be updated at the end
				1,              // bands  (for a spectral library is 1)
				2,              // data type    PENDING to generalize
				0               // byte order  (Intel)
		);
		
		/////////////////////////////////////////////////////////
		// wavelength values:
		// NOTE: ad hoc values: unfortunately GDAL does not provide a way
		// to access the wavelength meta-attribute from source dataset.
		// A solution for this is PENDING.
		fprintf(header_file,
			"wavelength = {"
		);
		for ( int i = 0; i < numBands; i++ ) {
			if ( i > 0 )
				fprintf(header_file, ",");
			fprintf(header_file, "\n%d", i+1);
		}
		fprintf(header_file, "\n}\n");
		
		
		// spectra names:
		fprintf(header_file,
			"spectra names = {"
		);
		
		currentFeature = NULL;
	}
	
	/**
	  * nothing is done.
	  */
	~EnviSlObserver() {
	}
	

	/**
	  *
	  */
	void init(GlobalInfo& info) { 
		typeSize = info.band.typeSize;
	}
	

	/**
	  * Used here to update currentFeature
	  */
	void intersectionFound(OGRFeature* feature) {
		currentFeature = feature;
	}

	
	/**
	  * Adds a spectrum to the output file.
	  * Each spectrum take a name with the following structure:
	  *      FID:col:row
	  */
	void addPixel(TraversalEvent& ev) { 
		int col = ev.pixel.col;
		int row = ev.pixel.row;
		void* band_values = ev.bandValues;
		
		// write bands to binary file:
		fwrite(band_values, typeSize, numBands, data_file);
		
		char spectrum_name[1024];
		sprintf(spectrum_name, "%ld:%d:%d", currentFeature->GetFID(), col, row);
		
		// add spectrum name
		if ( numSpectra > 0 )
			fprintf(header_file, ",");
		
		fprintf(header_file, "\n  %s", spectrum_name);
		
		/////////////////////
		// add class fields
		if ( class_file && select_fields ) {
			int num_fields = 0;
			char buff[strlen(select_fields) + 1];
			strcpy(buff, select_fields);
			for ( char* fname = strtok(buff, ","); fname; fname = strtok(NULL, ",") ) {
				if ( num_fields++ )
					fprintf(class_file, ", ");
				
				const int i = currentFeature->GetFieldIndex(fname);
				if ( i < 0 ) {
					fprintf(stderr, "\n\tField `%s' not found\n", fname);
					exit(1);
				}
				OGRFieldDefn* poField = currentFeature->GetFieldDefnRef(i);
				OGRFieldType ft = poField->GetType();
				switch(ft) {
					case OFTString: {
						const char* str = currentFeature->GetFieldAsString(i);
						fprintf(class_file, "%s", str);
						break;
					}
					case OFTInteger: { 
						int val = currentFeature->GetFieldAsInteger(i);
						fprintf(class_file, "%d", val);
						break;
					}
					case OFTReal: { 
						double val = currentFeature->GetFieldAsDouble(i);
						fprintf(class_file, "%f", val);
						break;
					}
					default:
						fprintf(stderr, "addPixel: expecting: "
								"OFTString, OFTInteger, or OFTReal \n");
						exit(2);
				}
			}
			fprintf(class_file, "\n");
		}		 
		
		
		numSpectra++;
	}
	
	/**
	  * Finishes the header file
	  */
	void _end() {
		// close spectra names section:
		fprintf(header_file, "\n}\n");
		
		// update number of lines:
		fseek(header_file, lines_offset, SEEK_SET);
		fprintf(header_file, "%*d", LINES_WIDTH, numSpectra);
	}
};


/**
  * implementation
  */
int starspan_gen_envisl(
	Raster* rast, 
	Vector* vect,
	const char* select_fields,
	const char* envisl_name
) {
	// output files
	char data_filename[1024];
	sprintf(data_filename, "%s.img", envisl_name);
	char header_filename[1024];
	sprintf(header_filename, "%s.hdr", envisl_name);
	
	FILE* data_file = fopen(data_filename, "w");
	if ( !data_file ) {
		fprintf(stderr, "Couldn't create %s\n", data_filename);
		return 1;
	}

	FILE* header_file = fopen(header_filename, "w");
	if ( !header_file ) {
		fclose(data_file);
		fprintf(stderr, "Couldn't create %s\n", header_filename);
		return 1;
	}
	
	FILE* class_file = NULL;
	if ( select_fields ) {
		char class_filename[1024];
		sprintf(class_filename, "%s_classes.txt", envisl_name);
		class_file = fopen(class_filename, "w");
		if ( !class_file ) {
			fclose(header_file);
			fclose(data_file);
			fprintf(stderr, "Couldn't create %s\n", class_filename);
			return 1;
		}
	}
	
	
	int bands;
	rast->getSize(NULL, NULL, &bands);
	EnviSlObserver obs(bands, data_file, header_file, class_file, select_fields);	
	Traverser tr(rast, vect);
	tr.setObserver(&obs);
	
	tr.traverse();
	
	obs._end();
	
	fclose(header_file);
	fclose(data_file);
	if ( class_file )
		fclose(class_file);
	fprintf(stdout, "numSpectra = %d\n", obs.numSpectra);
	fprintf(stdout, "envisl finished.\n");

	return 0;
}
		


