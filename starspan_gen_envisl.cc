//
// STARSpan project
// Carlos A. Rueda
// starspan_gen_envisl - generate envi spectral library ...
// $Id$
//

#include "starspan.h"           
#include "traverser.h"       

#include <stdlib.h>
#include <assert.h>

// used to write the number of lines in header since this is
// done in two passes: the first one in which the number of
// lines is unknown, and a sencond one to update it.
#define LINES_WIDTH 8



/**
  *
  */
class EnviSlObserver : public Observer {
public:
	int numBands;
	FILE* data_file;
	FILE* header_file;
	
	OGRFeature* current_feature;
	int numSignatures;	
	long lines_offset;
	
	/**
	  *
	  */
	EnviSlObserver(int bands, FILE* df, FILE* hf) {
		numBands = bands;
		data_file = df; 
		header_file = hf;
		
		numSignatures = 0;
		
		// first part of header:
		fprintf(header_file,
			"ENVI\n" 
			"description = {Generated by starspan}\n"
			"samples = %d\n"
			"lines = "
			,
				numBands     // samples
		);
		
		// take current file pointer to later update number of lines:
		lines_offset = ftell(header_file);
		fprintf(header_file,
			"%*d\n"
			"bands = %d\n"
			"header offset = 0\n"
			"file type = ENVI Spectral Library\n"
			"data type = %d\n"
			"interleave = bip\n"
			"sensor type = Unknown\n"
			"byte order = %d\n"
			,
				LINES_WIDTH, 0, // lines--to be updated at the end
				1,              // bands  (for a spectral library is 1)
				2,              // data type    PENDING to generalize
				0               // byte order  (Intel)
		);
		
		/////////////////////////////////////////////////////////
		// wavelength values:
		// NOTE: ad hoc values: unfortunately GDAL does not provide a way
		// to access the wavelength meta-attribute from source dataset.
		// A solution for this is PENDING.
		fprintf(header_file,
			"wavelength = {"
		);
		for ( int i = 0; i < numBands; i++ ) {
			if ( i > 0 )
				fprintf(header_file, ",");
			fprintf(header_file, "\n%d", i+1);
		}
		fprintf(header_file, "\n}\n");
		
		
		// spectra names:
		fprintf(header_file,
			"spectra names = {"
		);
		
		current_feature = NULL;
	}
	
	/**
	  *
	  */
	~EnviSlObserver() {
	}
	

	/**
	  * Used here to update current_feature
	  */
	void intersectionFound(OGRFeature* feature) {
		current_feature = feature;
	}

	
	/**
	  *
	  */
	void addPixel(TraversalEvent& ev) { 
		double x = ev.pixelLocation.x;
		double y = ev.pixelLocation.y;
		void* signature = ev.signature;
		int typeSize = ev.typeSize;
		
		// write signature to binary file:
		fwrite(signature, typeSize, numBands, data_file);
		
		char signature_name[1024];
		sprintf(signature_name, "%ld:%.3f:%.3f", current_feature->GetFID(), x, y);
		
		// add spectrum name
		if ( numSignatures > 0 )
			fprintf(header_file, ",");
		
		fprintf(header_file, "\n  %s", signature_name);
		
		numSignatures++;
	}
	
	/**
	  * Finishes the header file
	  */
	void _end() {
		// close spectra names section:
		fprintf(header_file, "\n}\n");
		
		// update number of lines:
		fseek(header_file, lines_offset, SEEK_SET);
		fprintf(header_file, "%*d", LINES_WIDTH, numSignatures);
	}
};


/**
  * implementation
  */
int starspan_gen_envisl(
	Raster* rast, 
	Vector* vect, 
	const char* envisl_name,
	const char* pszOutputSRS  // see gdal_translate option -a_srs 
	                         // If NULL, projection is taken from input dataset
) {
	// output files
	char data_filename[1024];
	sprintf(data_filename, "%s.img", envisl_name);
	char header_filename[1024];
	sprintf(header_filename, "%s.hdr", envisl_name);
	
	FILE* data_file = fopen(data_filename, "w");
	if ( !data_file ) {
		fprintf(stderr, "Couldn't create %s\n", data_filename);
		return 1;
	}

	FILE* header_file = fopen(header_filename, "w");
	if ( !header_file ) {
		fclose(data_file);
		fprintf(stderr, "Couldn't create %s\n", header_filename);
		return 1;
	}
	
	
	int bands;
	rast->getSize(NULL, NULL, &bands);
	EnviSlObserver obs(bands, data_file, header_file);	
	Traverser tr(rast, vect);
	tr.setObserver(&obs);
	
	tr.traverse();
	
	obs._end();
	
	fclose(header_file);
	fclose(data_file);
	fprintf(stdout, "numSignatures = %d\n", obs.numSignatures);
	fprintf(stdout, "envisl finished.\n");

	return 0;
}
		


